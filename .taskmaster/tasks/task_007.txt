# Task ID: 7
# Title: Implement Error Handling and Monitoring
# Status: pending
# Dependencies: 6
# Priority: medium
# Description: Create comprehensive error handling, logging, and monitoring for the image storage process.
# Details:
Implement a robust error handling and monitoring system:

```javascript
import winston from 'winston'
import { Logtail } from '@logtail/node'
import { LogtailTransport } from '@logtail/winston'

// Configure logging
const logtail = new Logtail(process.env.LOGTAIL_TOKEN)

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  defaultMeta: { service: 'image-storage-service' },
  transports: [
    new winston.transports.Console(),
    new LogtailTransport(logtail)
  ]
})

// Custom error classes
class ImageDownloadError extends Error {
  constructor(message, dalleUrl, statusCode) {
    super(message)
    this.name = 'ImageDownloadError'
    this.dalleUrl = dalleUrl
    this.statusCode = statusCode
  }
}

class StorageUploadError extends Error {
  constructor(message, filePath, storagePath) {
    super(message)
    this.name = 'StorageUploadError'
    this.filePath = filePath
    this.storagePath = storagePath
  }
}

class DatabaseUpdateError extends Error {
  constructor(message, designId) {
    super(message)
    this.name = 'DatabaseUpdateError'
    this.designId = designId
  }
}

// Error handling middleware for Express
function errorHandler(err, req, res, next) {
  // Log the error
  logger.error({
    message: err.message,
    stack: err.stack,
    name: err.name,
    ...err
  })
  
  // Send appropriate response based on error type
  if (err instanceof ImageDownloadError) {
    return res.status(502).json({
      error: 'Failed to download image from source',
      message: err.message
    })
  }
  
  if (err instanceof StorageUploadError) {
    return res.status(500).json({
      error: 'Failed to upload image to storage',
      message: err.message
    })
  }
  
  if (err instanceof DatabaseUpdateError) {
    return res.status(500).json({
      error: 'Failed to update database',
      message: err.message
    })
  }
  
  // Default error response
  res.status(500).json({
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'production' 
      ? 'An unexpected error occurred' 
      : err.message
  })
}

// Health check endpoint
function setupHealthCheck(app) {
  app.get('/health', async (req, res) => {
    try {
      // Check Supabase connection
      const { data, error } = await supabase.from('custom_design').select('id').limit(1)
      
      if (error) throw new Error(`Supabase DB error: ${error.message}`)
      
      // Check Supabase Storage
      const { data: bucketData, error: bucketError } = await supabase.storage.getBucket('design-images')
      
      if (bucketError) throw new Error(`Supabase Storage error: ${bucketError.message}`)
      
      res.json({ status: 'healthy', services: { database: 'connected', storage: 'connected' } })
    } catch (error) {
      logger.error('Health check failed:', error)
      res.status(500).json({ status: 'unhealthy', error: error.message })
    }
  })
}
```

Implement metrics collection:

```javascript
import prometheus from 'prom-client'

// Create metrics
const imageProcessingCounter = new prometheus.Counter({
  name: 'image_processing_total',
  help: 'Total number of processed images',
  labelNames: ['status']
})

const imageProcessingDuration = new prometheus.Histogram({
  name: 'image_processing_duration_seconds',
  help: 'Duration of image processing in seconds',
  buckets: [0.1, 0.5, 1, 2, 5, 10, 30]
})

const storageSize = new prometheus.Gauge({
  name: 'storage_size_bytes',
  help: 'Total size of stored images in bytes'
})

// Track metrics in the workflow
async function processDallEImageWithMetrics(designId, dalleUrl) {
  const timer = imageProcessingDuration.startTimer()
  
  try {
    const result = await processDallEImage(designId, dalleUrl)
    imageProcessingCounter.inc({ status: 'success' })
    return result
  } catch (error) {
    imageProcessingCounter.inc({ status: 'failure' })
    throw error
  } finally {
    timer()
  }
}

// Expose metrics endpoint
function setupMetricsEndpoint(app) {
  app.get('/metrics', async (req, res) => {
    res.set('Content-Type', prometheus.register.contentType)
    res.end(await prometheus.register.metrics())
  })
}
```

# Test Strategy:
1. Test error handling for various failure scenarios (network errors, storage errors, database errors)
2. Verify custom error classes provide appropriate context
3. Test logging to ensure all relevant information is captured
4. Verify metrics collection accurately tracks processing statistics
5. Test health check endpoint with both healthy and unhealthy services
6. Verify metrics endpoint returns valid Prometheus metrics
7. Test error handling middleware with different error types
8. Simulate service outages to verify monitoring alerts
